### 애그리거트와 트랜잭션

### 락 종류 정리

### 1. 선점 vs 비선점

| 구분 | 설명 |
| --- | --- |
| 선점(Predemptive) | 이미 자원을 점유한 스레드/프로세스라도, 다른 스레드가 강제로 자원을 가져갈 수 있음. 주로 OS CPU 스케줄링에서 사용. |
| 비선점(Non-preemptive) | 자원을 점유한 스레드/프로세스가 자발적으로 해제할 때까지 다른 스레드는 접근할 수 없음. 동기화 primitive에서 사용됨. |

### 2. 비관적 vs 낙관적 락

| 구분 | 설명 |
| --- | --- |
| 비관적 락(Pessimistic Lock) | 데이터 충돌이 많다고 가정하고, 접근 전에 먼저 락을 걸어 충돌을 방지함. 예: `SELECT ... FOR UPDATE` |
| 낙관적 락(Optimistic Lock) | 데이터 충돌이 적다고 가정하고, 수정 시점에 충돌 여부를 검사함. 충돌 시 롤백 후 재시도. 예: 버전 컬럼 비교, CAS |

### 3. 핵심 구분

- 선점/비선점: **자원을 다른 스레드/프로세스가 강제로 가져갈 수 있는가**
- 비관적/낙관적: **데이터 충돌을 어떻게 관리할 것인가**
- 비선점 잠금 ≠ 낙관적 락

오프라인 선점 잠금 : 단일 트랜잭션에서 동시 변경을 막는 선점 잠금 방식과는 달리 오프라인 선점 잠금은 여러 트랜잭션에 걸쳐 동시 변경을 막는다.

- **LockManager 인터페이스**: 자원에 대한 선점 락 획득, 해제, 소유자 조회, 만료 시간 설정 기능 제공
- **In-Memory 구현**: JVM 내 ConcurrentHashMap 등으로 락 상태 관리, TTL로 만료 처리
- **DB 기반 구현**: `locks` 테이블(resource_id, owner_id, expire_at)로 분산 환경에서도 락 공유 가능
- **락 획득 로직**: 이미 존재하거나 만료되지 않은 락은 획득 실패, TTL 경과 시 갱신 가능
- **락 해제 로직**: 소유자만 락 해제 가능
- **락 조회**: 현재 소유자 확인, 만료된 경우 null 반환
- **설계 고려 사항**
    - TTL(Time-To-Live)로 무한 대기 방지
    - 충돌 발생 시 재시도 전략 필요
    - In-Memory + DB 조합으로 성능 최적화 가능
