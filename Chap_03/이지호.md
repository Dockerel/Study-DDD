# 애그리거트

처음 도메인 모델을 만들기 시작하면 큰 애그리거트로 보이는 것들이 많지만, 도메인에 대한 경험이 생기고 도메인 규칙을 제대로 이해할수록 애그리거트의 실제 크기는 줄어든다

### 애그리거트 루트

애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티

- 핵심 역할: 애그리거트의 일관성이 꺠지지 않도록 하는 것
    - 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다
- 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안된다
    
    → 애그리거트 코드가 강제하는 규칙을 적용할 수 없기 때문
    

중요 규칙

- 단순히 필드를 변경하는 set 메서드를 public으로 만들지 않기
- 밸류 타입은 불변으로 구현

### 트랜잭션 범위

> **트랜잭션 범위는 작을수록 좋다**
> 

클수록 잠금 대상이 많아지고 → 동시에 처리할 수 있는 트랜잭션의 개수가 줄어들고 → 전체적인 성능 저하가 일어난다

- 한 애그리거트가 다른 애그리거트를 변경해서는 안된다
    
    → 만약 두 개 이상의 애그리거트를 변경해야 한다면 직접 수정하지 않고 응용 서비스에서 각각 변경한다
    

### Repository와 애그리거트

애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야 한다

why? 그렇지 않으면 `NullPointException`이 발생할 수도 있다

### ID를 이용한 애그리거트 참조

ORM 기술 덕에 애그리거트 루트에 대한 참조를 쉽게 구현할 수 있고 활용도 쉽다.

BUT,,

- 편한 탐색 오용 : 한 애그리거트에서 바로 연관된 애그리거트를 고치고 싶어짐
- 성능에 대한 고민 : 지연로딩과 즉시로딩 고민
- 확장 어려움 : 확장을 위해 하위 도메인마다 다른 DBMS에 저장하면 JPA 기술 사용 불가

> **따라서, 객체를 직접적으로 이용한 참조가 아닌 ID를 이용한 참조도 유용하다**
> 

지연 로딩을 하는 것과 동일한 결과를 만든다

복잡도를 낮추고, 한 애그리거트에서 다른애그리거트 수정을 근원적으로 막는다

애그리거트별로 다른 구현 기술사용이 가능해진다

BUT,, `N+1` 문제를 유발할 수 있다

→ 이를 해결하기 위해 `fetch join`, `entity graph` 등을 사용해 즉시 로딩하면 된다

### 애그리거트를 팩토리로 사용

도메인 자체의 필드값을 분기로 결정되는 문제가 있을 때

→ 일반적으로는 비즈니스 로직에서 도메인을 호출한 후 확인하여 exception을 던지는 등의 처리를 한다

BUT, 애그리거트를 팩토리로 사용하면 도메인단에서 어떠한 객체를 생성하는 팩토리 로직 자체에서 검증을 하여 보낼 수 있게 된다

→ 비즈니스 로직에 노출 최소화, OCP 가능

> **애그리거트 : 하나의 도메인 안에 모든 필드가 들어있는 게 아니라, 관련된 도메인 단위로 객체들을 나누고 그 객체들을 도메인 내부에 넣을 때 이 묶음이 애그리거트**
>
