# 리포지터리와 모델 구현

리포지터리 인터페이스는 도메인 영역, 구현체는 인프라영역

### 매핑 구현

애그리거트와 JPA 매핑을 위한 기본 규칙

- 애그리거트와 루트는 엔티티이므로 `@Entity`로 매핑 설정
- 밸류는 `@Embeddable`로 매핑 설정
- 밸류 타입 프로퍼티는 `@Embedded` 로 매핑 설정
    
    ![IMG_2258](https://github.com/user-attachments/assets/83f26975-5a25-4a69-8abb-4cca99bc3eb5)

    Entity가 벨류를 받을 때 `@Embedded` 로 받고, 밸류는 `@Embeddable` 로 선언됨
    
    > **JPA에서는 `@Entity`와 `@Embeddable` 로 클래스를 매핑하려면 기본 생성자를 넣어야한다**
    > 

객체가 제공할 기능 중심으로 엔티티를 구현하게끔  유도하려면 JPA 매핑 처리를 프로퍼티가 아닌, 필드 방식으로 해야 한다

### AttributeConverter

밸류 타입의 프로퍼티를 한 개 칼럼에 매핑해야 할 때 사용된다

![IMG_2259](https://github.com/user-attachments/assets/ec5d1c12-eec1-4c33-9e16-cf7c61221d98)

```jsx
@Convert(converter = MoneyConverter.class)
private Money totalAmounts;
```

이런식으로 사용 가능하다

밸류 컬랙션을 매핑하는 어노테이션도 있는데, 실제로 사용되는지 확인이 필요할듯

- SecondaryTable
- ElementCollection
- CollectionTable
- OrderColumn

등등,,

> **하이버네이트는 @Entity로 정의된 클래스에 대해서는 객체를 호출하기 때문에 밸류가 해당 방식으로 저장될 경우 삭제시 연쇄적 삭제시 여러번의 쿼리 호출로 제거되는데, @Embeddable 타입은 객체를 로딩하지 않고 한번의 delete 쿼리로 삭제 가능해서 성능 차이가 난다**
> 

### 애그리거트 로딩 전략

JPA 매핑을 설정할 때 항상 기억해야 할 점은 애그리거트에 속한 객체가 모두 모여야 완전한 하나가 된다는 것

- 조회 시점에서 애그리거트를 완전한 상태가 되도록 하려면 즉시 로딩을 하면 된다
    
    → 그러나 항상 좋은 것만은 아니다
    
    → 테이블이 엮여서 한번에 로딩될 경우 카타시안 조인을 사용해서 중복되며 탐색 수가 많아 성능 저하가 유발될 수 있다
    
    cf) 하이버네이트가 중복된 데이터를 알맞게 제거해주긴 한다
    

> **JPA는 트랜잭션 범위 내에서 지연 로딩을 허용하기 때문에 실제로 상태를 변경하는 시점에 필요한 구성요소만 로딩해도 문제가 되지 않는다**
> 

> 일반적인 서비스는 상태 변경 기능을 실행하는 빈도보다 조회 기능을 실행하는 빈도가 훨씬 높기 때문에 상태 변경을 위해 지연로딩을 사용할 때 발생하는 추가 쿼리로 인한 실행 속도 저하는 보통 문제 X
> 

→ 여기서 의문 : 조회가 많으면 그냥 즉시로딩 때리면 되는거 아닌가?

NO! 즉시로딩은 무조건 연관테이블까지 다 조회하는데, 지연로딩을 걸어두면 조회시 특정 필드만 조회할 경우 필요없는 다른 필드는 조회하지 않기 때문에 오히려 좋다

### 도메인 구현과 DIP

도메인 or 비즈니스단에서 직접적으로 JPA를 의존하면 안되고 인터페이스를 의존하면서 하위단에 인터페이스의 구현체를 만들어놓아 하위 모듈이 상위 모듈을 의존하게 의존 역전 시키면 된다

→ DDIP에서 적용되어있음
