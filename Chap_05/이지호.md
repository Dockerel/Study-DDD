> 시작에 앞서, 글쓴이는 조회 모델을 구현할 때 JPA를 사용할 때도 있지만 MyBatis, jdbcTemplate 등 다양한 방식을 사용한다. 모든 DB 연동 코드를 JPA만 사용해서 구현해야 한다고 생각하면 안된다
> 

### 검색을 위한 스펙

검색 조건을 다양하게 조합해야 할 때 사용할 수 있는 것 : 스펙(Specification)

```jsx
public interface Speficiation<T> {
	public boolean isStatisfiedBy(T agg);
}
```

리포지터리가 스펙을 이용해서 검색 대상을 걸러주므로 특정 조건을 충족하는 애그리거트를 찾고 싶으면 원하는 스펙을 생성해서 리포지터리에 전달해 주기만 하면 된다

### 스프링 데이터 JPA를 이용한 스펙 구현

스펙 인터페이스에서 지네릭 타입 파라미터 T는 JPA 엔티티 타입을 의미한다.

스펙 인터페이스는 함수형 인터페이스이므로 람다식을 이용해서 객체를 생성할 수 있다.

### 스펙 조합

스프링 데이터 JPA가 제공하는 스펙 인터페이스는 스펙을 조합할 수 있는 두 메서드를 제공하고 있다

→ AND, OR

정적메서드 NOT을 사용해서 조건을 반대로 적용할 수도 있다

Where 메서드를 사용하면 null 여부를 편하게 검사할 수 있다

### 동적 인스턴스 생성

JPA는 쿼리 결과에서 임의의 객체를 동적으로 생성할 수 있는 기능을 제공하고 있다
![IMG_2312 JPG](https://github.com/user-attachments/assets/d587ff21-91c8-4a81-bd94-917dee457ee0)

select 절을 보면 new 키둬드가 있고, 해당 키워드 뒤에 생성할 인스턴스의 완전한 클래스 이름을 지정하고 괄호 안에 생성자와 인자로 전달할 값을 지정한다

동적 인스턴스의 장점은 JPQL을 그대로 사용하므로 객체 기준으로 쿼리를 작성하면서도 동시에 지연/즉시 같은 고민 없이 원하는 모습을 데이터를 조회할 수 있다는 점이다

### @Subselect

하이버네이트는 JPA 확장 기능으로 `@Subselect`를 지원한다

: 쿼리 결과를 `@Entity`로 매핑할 수 있는 유용한 기능

뷰를 수정할 수 없듯이 `@Subselect` 로 조회한 `@Entity` 역시 수정할 수 없다

`@immutable` 을 사용하면 하이버네이트는 해당 엔티티의 필드/프로퍼티가 변경되어도 DB에 반영하지 않고 무시한다.
